1. 假定eor=0,然后eor异或arr[i]
2. 得到的结果是`eor==a^b`
3. 利用a!=b,则a和b的二进制数一定有一位不同，a^b一定有一位为1；
4. 取出最右侧的1，即`rightOne = eor & (-eor + 1)`
5. 假定eorr=0，如果arr[i]的最右侧的1与rightOne相同，则eorr异或arr[i]，得到结果为a和b中的一个,假定为a
6. `a=eorr`, `b=eor^eorr`
```go
func oddTimestwoKind(arr []int) (int, int) {
	eor := 0
	for i := 0; i < len(arr); i++ {
		eor ^= arr[i]
	}
	/*
	eor = a^b
	 */
	rightOne := eor & (-eor + 1)
	// rightOne 是 a^b 最右侧 1的位
	eorr := 0
	for j := 0; j < len(arr); j++ {
		if (rightOne&arr[j]) != 0 {
			// 找出rightOne位 为 1  的数
			eorr ^= arr[j]
			// a ^ b ^ b
		}
	}
	 a := eorr
	 b := eor ^ eorr
	 return a,b
}
```

